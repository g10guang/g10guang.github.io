<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Begin Jekyll SEO tag v2.4.0 -->
<title>字符串中的子串问题 | 刘曦光</title>
<meta name="generator" content="Jekyll v3.7.2" />
<meta property="og:title" content="字符串中的子串问题" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="问题描述" />
<meta property="og:description" content="问题描述" />
<link rel="canonical" href="http://localhost:4000/%E7%AE%97%E6%B3%95/2018/04/11/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98.html" />
<meta property="og:url" content="http://localhost:4000/%E7%AE%97%E6%B3%95/2018/04/11/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98.html" />
<meta property="og:site_name" content="刘曦光" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-04-11T20:00:05+08:00" />
<script type="application/ld+json">
{"description":"问题描述","@type":"BlogPosting","url":"http://localhost:4000/%E7%AE%97%E6%B3%95/2018/04/11/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98.html","headline":"字符串中的子串问题","dateModified":"2018-04-11T20:00:05+08:00","datePublished":"2018-04-11T20:00:05+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/%E7%AE%97%E6%B3%95/2018/04/11/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <link rel="stylesheet" href="/assets/main.css">
  <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="刘曦光" />
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">
    
    
    <a class="site-title" rel="author" href="/">刘曦光</a>

    
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
          
            
            
            <a class="page-link" href="/about/">About</a>
            
          
            
            
          
            
            
          
            
            
          
        </div>
      </nav>
    
  </div>
</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">字符串中的子串问题</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2018-04-11T20:00:05+08:00" itemprop="datePublished">
        
        Apr 11, 2018
      </time>
      </p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1 id="问题描述">问题描述</h1>

<p>在阅读《编程珠玑》第二版字符串一章中提到了一个解决寻找最长子串的问题的方案，之前还没见识过这方案，今天阅读后觉得有必要 mark down。</p>

<p><strong>如何寻找字符串中重复出现的最长子串？</strong></p>

<h1 id="算法介绍">算法介绍</h1>

<blockquote>
  <p>注意：以下代码使用 Go 实现。简单起见，假设所有输入都是 ASCII 编码的字符，因为 Go 使用 UTF-8 编码，解码 utf-8 操作需要额外操作，而这里以介绍算法为主。</p>
</blockquote>

<p>Go 中采用了类似 Java 的字符串池化的概念，取子串的消耗非常低，因为底层复用了父字符串，所以在算法实现中使用了大量的取字符串的子串操作。</p>

<p>先定义一个用于计算两个字符串相同前缀的长度的函数：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">commonLen</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="x"> </span><span class="n">j</span><span class="x"> </span><span class="kt">int</span><span class="p">,</span><span class="x"> </span><span class="n">s</span><span class="x"> </span><span class="kt">string</span><span class="p">)</span><span class="x"> </span><span class="p">(</span><span class="n">cnt</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="k">if</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">&gt;</span><span class="x"> </span><span class="n">j</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="n">i</span><span class="p">,</span><span class="x"> </span><span class="n">j</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">j</span><span class="p">,</span><span class="x"> </span><span class="n">i</span><span class="x">
    </span><span class="p">}</span><span class="x">
    </span><span class="k">for</span><span class="x"> </span><span class="n">j</span><span class="x"> </span><span class="o">&lt;</span><span class="x"> </span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="x"> </span><span class="o">&amp;&amp;</span><span class="x"> </span><span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="x"> </span><span class="o">==</span><span class="x"> </span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="n">cnt</span><span class="o">++</span><span class="x">
        </span><span class="n">i</span><span class="o">++</span><span class="x">
        </span><span class="n">j</span><span class="o">++</span><span class="x">
    </span><span class="p">}</span><span class="x">
    </span><span class="k">return</span><span class="x"> </span><span class="n">cnt</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<h2 id="嵌套循环">嵌套循环</h2>

<p>最简单的解决方案是使用两个循环进行比较：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">TwoCircle</span><span class="p">(</span><span class="n">source</span><span class="x"> </span><span class="kt">string</span><span class="p">)</span><span class="x"> </span><span class="kt">string</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">maxLen</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">0</span><span class="x">
    </span><span class="n">maxStart</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">0</span><span class="x">
    </span><span class="k">for</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">0</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">&lt;</span><span class="x"> </span><span class="nb">len</span><span class="p">(</span><span class="n">source</span><span class="p">)</span><span class="o">-</span><span class="m">1</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="o">++</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="k">for</span><span class="x"> </span><span class="n">j</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">+</span><span class="x"> </span><span class="m">1</span><span class="p">;</span><span class="x"> </span><span class="n">j</span><span class="x"> </span><span class="o">&lt;</span><span class="x"> </span><span class="nb">len</span><span class="p">(</span><span class="n">source</span><span class="p">);</span><span class="x"> </span><span class="n">j</span><span class="o">++</span><span class="x"> </span><span class="p">{</span><span class="x">
            </span><span class="k">if</span><span class="x"> </span><span class="n">r</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">commonLen</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="x"> </span><span class="n">j</span><span class="p">,</span><span class="x"> </span><span class="n">source</span><span class="p">);</span><span class="x"> </span><span class="n">r</span><span class="x"> </span><span class="o">&gt;</span><span class="x"> </span><span class="n">maxLen</span><span class="x"> </span><span class="p">{</span><span class="x">
                </span><span class="n">maxLen</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">r</span><span class="x">
                </span><span class="n">maxStart</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">i</span><span class="x">
            </span><span class="p">}</span><span class="x">
        </span><span class="p">}</span><span class="x">
    </span><span class="p">}</span><span class="x">
    </span><span class="k">return</span><span class="x"> </span><span class="n">source</span><span class="p">[</span><span class="n">maxStart</span><span class="o">:</span><span class="x"> </span><span class="n">maxStart</span><span class="o">+</span><span class="n">maxLen</span><span class="p">]</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<ul>
  <li>空间复杂度：<code class="highlighter-rouge">O(n^2)</code></li>
  <li>时间复杂度：<code class="highlighter-rouge">O(1)</code></li>
</ul>

<h2 id="后缀数组">后缀数组</h2>

<p><strong>Step 1</strong> 从第 0 个位置开始，每次切割切割字符串中头部，比如 banana，定义指针数组 <code class="highlighter-rouge">char *a[6]</code>：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">"banana"</span>
<span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">"anana"</span>
<span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s">"nana"</span>
<span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="s">"ana"</span>
<span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="s">"na"</span>
<span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="s">"a"</span>
</code></pre></div></div>

<p><strong>规律：每个字符串拥有相同的后缀</strong></p>

<p><strong>step 2</strong> 对 a 指针数组进行排序，其比较规则是根据指针指向数组的大小，结果为：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">"a"</span>
<span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">"ana"</span>
<span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s">"anana"</span>
<span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="s">"banana"</span>
<span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="s">"na"</span>
<span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="s">"nana"</span>
</code></pre></div></div>

<p><strong>规律：具有相同前缀的字符串互相相邻</strong></p>

<p><strong>step 3</strong> 遍历数组 a 比较相邻元素，找出最长子串长度。上面的排序操作的目的就是为了让具有相同前缀的字符串相邻，这样进行比较操作时，只需要与相邻元素进行比较，而不需要从头到尾进行比较。</p>

<p>显而易见，最长子串是：<code class="highlighter-rouge">ana</code></p>

<h3 id="代码实现">代码实现</h3>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">SuffixArray</span><span class="p">(</span><span class="n">source</span><span class="x"> </span><span class="kt">string</span><span class="p">)</span><span class="x"> </span><span class="kt">string</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="c">// 因为 Go 中指针不可运算，所以这里我们存储的是字符的起始位置</span><span class="x">
    </span><span class="n">sarr</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="x"> </span><span class="nb">len</span><span class="p">(</span><span class="n">source</span><span class="p">))</span><span class="x">
    </span><span class="k">for</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">0</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">&lt;</span><span class="x"> </span><span class="nb">len</span><span class="p">(</span><span class="n">sarr</span><span class="p">);</span><span class="x"> </span><span class="n">i</span><span class="o">++</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="n">sarr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">i</span><span class="x">
    </span><span class="p">}</span><span class="x">
    </span><span class="n">ssa</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">StringSuffixArray</span><span class="p">{</span><span class="n">sarr</span><span class="o">:</span><span class="n">sarr</span><span class="p">,</span><span class="x"> </span><span class="n">source</span><span class="o">:</span><span class="n">source</span><span class="p">}</span><span class="x">
    </span><span class="n">sort</span><span class="o">.</span><span class="n">Sort</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ssa</span><span class="p">)</span><span class="x">
    </span><span class="c">// 对排序后的子字符串，每个字符串与右边字符串进行比较，寻找字符串中重复出现的最长子串</span><span class="x">
    </span><span class="n">maxStart</span><span class="p">,</span><span class="x"> </span><span class="n">maxLen</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">0</span><span class="p">,</span><span class="x"> </span><span class="m">0</span><span class="x">
    </span><span class="k">for</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">0</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">&lt;</span><span class="x"> </span><span class="nb">len</span><span class="p">(</span><span class="n">sarr</span><span class="p">)</span><span class="x"> </span><span class="o">-</span><span class="x"> </span><span class="m">1</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="o">++</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="k">if</span><span class="x"> </span><span class="n">r</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">commonLen</span><span class="p">(</span><span class="n">sarr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="x"> </span><span class="n">sarr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="m">1</span><span class="p">],</span><span class="x"> </span><span class="n">source</span><span class="p">);</span><span class="x"> </span><span class="n">r</span><span class="x"> </span><span class="o">&gt;</span><span class="x"> </span><span class="n">maxLen</span><span class="x"> </span><span class="p">{</span><span class="x">
            </span><span class="n">maxLen</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">r</span><span class="x">
            </span><span class="n">maxStart</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">sarr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="x">
        </span><span class="p">}</span><span class="x">
    </span><span class="p">}</span><span class="x">
    </span><span class="k">return</span><span class="x"> </span><span class="n">source</span><span class="p">[</span><span class="n">maxStart</span><span class="o">:</span><span class="n">maxStart</span><span class="o">+</span><span class="n">maxLen</span><span class="p">]</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="c">// 以下代码是为实现 sort.Interface 接口，使用 Go 自带的快速排序算法</span><span class="x">
</span><span class="k">type</span><span class="x"> </span><span class="n">StringSuffixArray</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">sarr</span><span class="x">   </span><span class="p">[]</span><span class="kt">int</span><span class="x">
    </span><span class="n">source</span><span class="x"> </span><span class="kt">string</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">s</span><span class="x"> </span><span class="o">*</span><span class="n">StringSuffixArray</span><span class="p">)</span><span class="x"> </span><span class="n">Less</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="x"> </span><span class="n">j</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="kt">bool</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="k">return</span><span class="x"> </span><span class="n">strings</span><span class="o">.</span><span class="n">Compare</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">sarr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">:</span><span class="p">],</span><span class="x"> </span><span class="n">s</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">sarr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">:</span><span class="p">])</span><span class="x"> </span><span class="o">&lt;</span><span class="x"> </span><span class="m">0</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">s</span><span class="x"> </span><span class="o">*</span><span class="n">StringSuffixArray</span><span class="p">)</span><span class="x"> </span><span class="n">Swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="x"> </span><span class="n">j</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">s</span><span class="o">.</span><span class="n">sarr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="x"> </span><span class="n">s</span><span class="o">.</span><span class="n">sarr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">s</span><span class="o">.</span><span class="n">sarr</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="x"> </span><span class="n">s</span><span class="o">.</span><span class="n">sarr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">s</span><span class="x"> </span><span class="o">*</span><span class="n">StringSuffixArray</span><span class="p">)</span><span class="x"> </span><span class="n">Len</span><span class="p">()</span><span class="x"> </span><span class="kt">int</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="k">return</span><span class="x"> </span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">sarr</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<ul>
  <li>时间复杂度：<code class="highlighter-rouge">O(nlogn)</code></li>
  <li>空间复杂度：<code class="highlighter-rouge">O(n)</code></li>
</ul>

<p>基于后缀数组实现查找字符串中重复出现的最长子串算法，时间主要花费在对子串进行排序。</p>

<h2 id="衍生问题">衍生问题</h2>

<p>已经找到了“查找重复出现的最长子串”（问题一）的算法，那请思考如何实现“查找重复出现至少 M 次的最长子串”（问题二）？</p>

<p>可以尝试着寻找问题一与问题二有哪些共通之处：</p>

<ol>
  <li>重复出现</li>
  <li>子串</li>
</ol>

<p>在阅读下面之前希望读者先花几分钟思考一样如何使用<strong>后缀数组</strong>实现。</p>

<h3 id="解决算法">解决算法</h3>

<p>对后缀数组排序后得到的子串的特点是：</p>

<ol>
  <li>每个字符串具有相同的后缀</li>
  <li>具有相同、相似前缀的字符串相邻</li>
</ol>

<p>这里假设一个字符串：”bananana”，寻找重复出现至少 3 次的最长子串。</p>

<p><strong>step 1</strong> 从头到为取后缀子串：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">"bananana"</span>
<span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">"ananana"</span>
<span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s">"nanana"</span>
<span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="s">"anana"</span>
<span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="s">"nana"</span>
<span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="s">"ana"</span>
<span class="n">a</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="s">"na"</span>
<span class="n">a</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="s">"a"</span>
</code></pre></div></div>

<p><strong>step 2</strong> 对后缀数组进行排序，得到结果：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">"a"</span>
<span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">"ana"</span>
<span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s">"anana"</span>
<span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="s">"ananana"</span>
<span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="s">"bananana"</span>
<span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="s">"na"</span>
<span class="n">a</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="s">"nana"</span>
<span class="n">a</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="s">"nanana"</span>
</code></pre></div></div>

<p>比较子串相同部分的长度主要是比较其前缀，和相邻元素进行比较是寻找重复出现至少 2 次的子串（这个结论很重要）。</p>

<p>那么要寻找至少重复出现 M 次的子串，则只需要 <code class="highlighter-rouge">a[i]</code> 与 <code class="highlighter-rouge">a[i+M-1]</code> 进行前缀对比，找出相同前缀的长度。</p>

<p>为什么？</p>

<p>因为如果 <code class="highlighter-rouge">a[i]</code> 与 <code class="highlighter-rouge">a[i+M-1]</code> 具有相同的前缀 prefix，那么可以证明 <code class="highlighter-rouge">a[i]</code> 与 <code class="highlighter-rouge">a[i+1]</code>、<code class="highlighter-rouge">a[i+2]</code>….<code class="highlighter-rouge">a[i+M-1]</code> 都具有 prefix 前缀，<code class="highlighter-rouge">a[i]</code>…<code class="highlighter-rouge">a[i+M-1]</code> 共有 M 个子串，所以能够保证 prefix 至少重复出现了 M 次。（可以借鉴 “bananana” 的排序后的子串）</p>

<h3 id="代码实现-1">代码实现</h3>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">SubStringDuplicateMTimes</span><span class="p">(</span><span class="n">source</span><span class="x"> </span><span class="kt">string</span><span class="p">,</span><span class="x"> </span><span class="n">M</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="kt">string</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="k">if</span><span class="x"> </span><span class="n">M</span><span class="x"> </span><span class="o">&lt;=</span><span class="x"> </span><span class="m">1</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="k">return</span><span class="x"> </span><span class="n">source</span><span class="x">
    </span><span class="p">}</span><span class="x">
    </span><span class="n">sarr</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="x"> </span><span class="nb">len</span><span class="p">(</span><span class="n">source</span><span class="p">))</span><span class="x">
    </span><span class="k">for</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">0</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">&lt;</span><span class="x"> </span><span class="nb">len</span><span class="p">(</span><span class="n">sarr</span><span class="p">);</span><span class="x"> </span><span class="n">i</span><span class="o">++</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="n">sarr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">i</span><span class="x">
    </span><span class="p">}</span><span class="x">
    </span><span class="n">ssa</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">StringSuffixArray</span><span class="p">{</span><span class="n">sarr</span><span class="o">:</span><span class="n">sarr</span><span class="p">,</span><span class="x"> </span><span class="n">source</span><span class="o">:</span><span class="n">source</span><span class="p">}</span><span class="x">
    </span><span class="n">sort</span><span class="o">.</span><span class="n">Sort</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ssa</span><span class="p">)</span><span class="x">
    </span><span class="n">maxStart</span><span class="p">,</span><span class="x"> </span><span class="n">maxLen</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">0</span><span class="p">,</span><span class="x"> </span><span class="m">0</span><span class="x">
    </span><span class="c">// 从后往前遍历</span><span class="x">
    </span><span class="k">for</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="nb">len</span><span class="p">(</span><span class="n">sarr</span><span class="p">)</span><span class="x"> </span><span class="o">-</span><span class="x"> </span><span class="m">1</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">-</span><span class="x"> </span><span class="n">M</span><span class="x"> </span><span class="o">+</span><span class="x"> </span><span class="m">1</span><span class="x"> </span><span class="o">&gt;=</span><span class="x"> </span><span class="m">0</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="o">--</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="k">if</span><span class="x"> </span><span class="n">r</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">commonLen</span><span class="p">(</span><span class="n">sarr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="x"> </span><span class="n">sarr</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">M</span><span class="o">+</span><span class="m">1</span><span class="p">],</span><span class="x"> </span><span class="n">source</span><span class="p">);</span><span class="x"> </span><span class="n">r</span><span class="x"> </span><span class="o">&gt;</span><span class="x"> </span><span class="n">maxLen</span><span class="x"> </span><span class="p">{</span><span class="x">
            </span><span class="n">maxLen</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">r</span><span class="x">
            </span><span class="n">maxStart</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">sarr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="x">
        </span><span class="p">}</span><span class="x">
    </span><span class="p">}</span><span class="x">
    </span><span class="k">return</span><span class="x"> </span><span class="n">source</span><span class="p">[</span><span class="n">maxStart</span><span class="o">:</span><span class="n">maxStart</span><span class="o">+</span><span class="n">maxLen</span><span class="p">]</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<h1 id="写在最后">写在最后</h1>

<p>《编程珠玑》中多次提到不要用几分钟思考算法，用几个小时去实现；而应该用一个小时去思考，几十分钟去实现。厉害的程序员总是很“懒”的，大部分时间都不在写代码，而是思考。</p>

  </div>

  

  <a class="u-url" href="/%E7%AE%97%E6%B3%95/2018/04/11/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98.html" hidden></a>
</article>

      </div>
    </main>

    <footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">刘曦光</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">
            
              刘曦光
            
            </li>
            
            <li><a class="u-email" href="mailto:g10guang@foxmail.com">g10guang@foxmail.com</a></li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
  
  
  
  <li><a href="https://github.com/g10guang"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">g10guang</span></a></li>
  
  
  
  
  
  
  
</ul>

      </div>

      <div class="footer-col footer-col-3">
        <p>我会在这里分享我的成长经历、心得，既有IT方面的，也有生活读书方面的。</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
