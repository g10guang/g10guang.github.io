<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Begin Jekyll SEO tag v2.4.0 -->
<title>《Go程序设计语言》笔记一 | 刘曦光</title>
<meta name="generator" content="Jekyll v3.7.2" />
<meta property="og:title" content="《Go程序设计语言》笔记一" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="标准输入输出" />
<meta property="og:description" content="标准输入输出" />
<link rel="canonical" href="http://localhost:4000/golang/2018/03/02/the-go-programing-languange-note1.html" />
<meta property="og:url" content="http://localhost:4000/golang/2018/03/02/the-go-programing-languange-note1.html" />
<meta property="og:site_name" content="刘曦光" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-03-02T12:00:05+08:00" />
<script type="application/ld+json">
{"description":"标准输入输出","@type":"BlogPosting","url":"http://localhost:4000/golang/2018/03/02/the-go-programing-languange-note1.html","headline":"《Go程序设计语言》笔记一","dateModified":"2018-03-02T12:00:05+08:00","datePublished":"2018-03-02T12:00:05+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/golang/2018/03/02/the-go-programing-languange-note1.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <link rel="stylesheet" href="/assets/main.css">
  <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="刘曦光" />
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">
    
    
    <a class="site-title" rel="author" href="/">刘曦光</a>

    
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
          
            
            
            <a class="page-link" href="/about/">About</a>
            
          
            
            
          
            
            
          
            
            
          
        </div>
      </nav>
    
  </div>
</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">《Go程序设计语言》笔记一</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2018-03-02T12:00:05+08:00" itemprop="datePublished">
        
        Mar 2, 2018
      </time>
      </p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1 id="标准输入输出">标准输入输出</h1>

<p>编程语言中的标准流如，<strong>stdin</strong> / <strong>stdout</strong> / <strong>stderr</strong> 是指向操作系统中的文件，以 Linux 为例，以下是 <code class="highlighter-rouge">os.Stdin</code> <code class="highlighter-rouge">os.Stdout</code> <code class="highlighter-rouge">os.Stderr</code> 的定义：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span><span class="x"> </span><span class="p">(</span><span class="x">
    </span><span class="n">Stdin</span><span class="x">  </span><span class="o">=</span><span class="x"> </span><span class="n">NewFile</span><span class="p">(</span><span class="kt">uintptr</span><span class="p">(</span><span class="n">syscall</span><span class="o">.</span><span class="n">Stdin</span><span class="p">),</span><span class="x"> </span><span class="s">"/dev/stdin"</span><span class="p">)</span><span class="x">
    </span><span class="n">Stdout</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">NewFile</span><span class="p">(</span><span class="kt">uintptr</span><span class="p">(</span><span class="n">syscall</span><span class="o">.</span><span class="n">Stdout</span><span class="p">),</span><span class="x"> </span><span class="s">"/dev/stdout"</span><span class="p">)</span><span class="x">
    </span><span class="n">Stderr</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">NewFile</span><span class="p">(</span><span class="kt">uintptr</span><span class="p">(</span><span class="n">syscall</span><span class="o">.</span><span class="n">Stderr</span><span class="p">),</span><span class="x"> </span><span class="s">"/dev/stderr"</span><span class="p">)</span><span class="x">
</span><span class="p">)</span><span class="x">
</span></code></pre></div></div>

<p>从控制台输入 <code class="highlighter-rouge">os.Stdin</code>，</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">readFromStdin</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">reader</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">bufio</span><span class="o">.</span><span class="n">NewReader</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">Stdin</span><span class="p">)</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"enter text:"</span><span class="p">)</span><span class="x">
    </span><span class="n">text</span><span class="p">,</span><span class="x"> </span><span class="n">_</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">reader</span><span class="o">.</span><span class="n">ReadString</span><span class="p">(</span><span class="sc">'\n'</span><span class="p">)</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">text</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>fmt 包中提供了强大的格式化功能，可以使用 <code class="highlighter-rouge">fmt.Sprintf</code> 方法格式化字符串，该方法类似 <code class="highlighter-rouge">fmt.Printf</code> 区别是前者是将格式化的字符串作为返回结果，后者直接将格式化后的字符串输出到控制台。如果需要将格式化的字符串输出到流（实现了 <code class="highlighter-rouge">io.Writer</code>接口）中，可以调用 <code class="highlighter-rouge">fmt.Fprintf</code>。</p>

<h1 id="获取运行命令的参数">获取运行命令的参数</h1>

<p>运行命令的参数保存在 <code class="highlighter-rouge">os.Args</code> []string 中</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">(){</span><span class="x">
    </span><span class="n">args</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">os</span><span class="o">.</span><span class="n">Args</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>假如我们使用 <code class="highlighter-rouge">go run main.go hello world</code> 命令来运行，得到不是 <code class="highlighter-rouge">["go run main.go", "hello", "world"]</code>，在我本机是：<code class="highlighter-rouge">["/tmp/go-build610217828/command-line-arguments/_obj/exe/readStdin", "hello", "world"]</code>。我们可以通过 <code class="highlighter-rouge">go run -x main.go hello world</code> 查看命令执行的过程。</p>

<h1 id="const">const</h1>

<p>Go 中常量只能是 字符串、数值、布尔值，复杂类型如slice、map、数组、结构体、指针、接口、函数等都无法声明为常量。</p>

<h1 id="var">var</h1>

<p>只有 chan、slice、map、函数、指针、接口变量 可以与 nil 做 <code class="highlighter-rouge">==</code> <code class="highlighter-rouge">!=</code> 比较，数组和结构体在声明时如果没有赋值，那么就会分配存储空间，然后将内容写为对应的默认值、</p>

<p>包级别的变量、常量在 <strong>init</strong> 函数开始前进行初始化，而 <strong>init</strong> 函数的执行在 <strong>main</strong> 函数之前。</p>

<p>只有变量才能够使用 <code class="highlighter-rouge">&amp;</code> 操作符，也就是没有指针能够指向常量。</p>

<p>当两个指针变量指向同一个变量或者是两个指针都是零值 nil 时候，使用 <code class="highlighter-rouge">==</code> 比较得到 <strong>true</strong></p>

<p>可以使用 <strong>flag</strong> 包来开发命令行工具，flag 为我们解析参数提供了很大的帮助</p>

<p>任何一个包、任何一个 .go 文件可以包含任意多个 <code class="highlighter-rouge">func init(){...}</code> 函数，在初始化包的时候将会按照 init 函数声明的顺序来执行 init 函数。</p>

<p>包初始化顺序：</p>
<ol>
  <li>按照 <strong>import</strong> 顺序完成引入的包的初始化</li>
  <li>根据编译器导入 .go 文件的顺序进行包级别变量的初始化</li>
  <li>按照 <strong>init</strong> 函数的声明顺序，执行所有 init 函数</li>
</ol>

<p>pointer / slice / map / function / channel 都是引用类型，共同特点是全部都间接地指向程序变量或者状态，于是操作所引用数据的效果就会遍历该数据的全部引用。</p>

<h1 id="类型">类型</h1>

<p>在不同编程语言中，去模 mod 运算 <strong>%</strong> 有不同表现，在 Go 中，取模余数的正负号总是与<em>被除数</em>一致，<code class="highlighter-rouge">-5 % 3 == -2</code> <code class="highlighter-rouge">-5 % -3 == -2</code>。题外话，Python 中去模余数总是和<em>除数</em>的正负号一致，<code class="highlighter-rouge">-5 % 3 == 1</code> <code class="highlighter-rouge">-5 % -3 == -2</code></p>

<p>无论是有符号数还是无符号数，若表示的运算结果所需要的位超过了该类型的范围，就会产生<strong>溢出</strong>。</p>

<p>对于 uint8</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span><span class="x"> </span><span class="n">u</span><span class="x"> </span><span class="kt">uint</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="m">255</span><span class="x">
</span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="x"> </span><span class="n">u</span><span class="o">+</span><span class="m">1</span><span class="p">,</span><span class="x"> </span><span class="n">u</span><span class="o">*</span><span class="n">u</span><span class="p">)</span><span class="x">    </span><span class="c">// 255 0 1</span><span class="x">
</span></code></pre></div></div>

<p>其中 <code class="highlighter-rouge">255 * 255</code> 结果的二进制形式为 <code class="highlighter-rouge">1111111000000001</code>，所以采取截断，最后结果为 1； 
<code class="highlighter-rouge">u+1</code> 的结果的类型依然是 <code class="highlighter-rouge">uint8</code></p>

<p>类似地，对于 int8</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="kt">int8</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="m">127</span><span class="x">
</span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="x"> </span><span class="n">u</span><span class="o">+</span><span class="m">1</span><span class="p">,</span><span class="x"> </span><span class="n">u</span><span class="o">*</span><span class="n">u</span><span class="p">)</span><span class="x">    </span><span class="c">// 127 -128 1</span><span class="x">
</span></code></pre></div></div>

<h2 id="-">^ &amp;^</h2>

<p>相对与 C 语言的不同，在 Go 中 <code class="highlighter-rouge">^</code> 运算符既可以作为一元运算符，也可以作为二元运算符：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span><span class="x"> </span><span class="n">u</span><span class="x"> </span><span class="kt">uint8</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="m">255</span><span class="x">
</span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="o">^</span><span class="n">u</span><span class="p">)</span><span class="x">     </span><span class="c">// 0</span><span class="x">
</span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">u</span><span class="o">^</span><span class="m">1</span><span class="p">)</span><span class="x">    </span><span class="c">//254</span><span class="x">
</span></code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">^</code> 作为一元运算符时，是按位取反，相当于 C 中的 <code class="highlighter-rouge">~</code></li>
  <li><code class="highlighter-rouge">^</code> 作为二元运算符时，是按位异或</li>
</ul>

<p>Go 中还有一个 C 中没有的运算符 <code class="highlighter-rouge">&amp;^</code> 按位清空。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span><span class="x"> </span><span class="n">u</span><span class="x"> </span><span class="kt">uint8</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="m">11</span><span class="x">
</span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">u</span><span class="o">&amp;^</span><span class="m">1</span><span class="p">)</span><span class="x">   </span><span class="c">// 254</span><span class="x">
</span></code></pre></div></div>

<p><code class="highlighter-rouge">x&amp;^y</code> 的位运算中，将 y 中对应位为 1 的位置，将 x 中对应位置置为 0，否则保持 x 中对应位置不变，对于 uint8 <code class="highlighter-rouge">11 &amp;^ 3 == 8</code></p>

<h2 id="fmtprintf">fmt.Printf</h2>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%d %[1]o %[1]x %[1]b</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="x"> </span><span class="m">100</span><span class="p">)</span><span class="x">
</span></code></pre></div></div>

<p>其中 <code class="highlighter-rouge">[1]</code> 表示使用第一个参数</p>

<h2 id="字符串">字符串</h2>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="s">"hello, 世界"</span><span class="x">
</span><span class="n">b</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="p">[]</span><span class="kt">byte</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="x">
</span><span class="n">s</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="kt">string</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="x">
</span></code></pre></div></div>

<p>上述字符串转化为 []byte，[]byte 转化为 string 时候都会发生重新分配内存空间，然后再进行内存的复制。因为 string 底层是不可以改变的，如果底层数组进行复用，则会造成改变 []byte 的值会间接改变 string 的内容，进行很多这样的操作会使得程序执行非常低效。但是<strong>某些编译器</strong>能够识别到如果后续 []byte 不会再改变的话，string 会复用 []byte 底层的数组。</p>

<p>若要进行很多关于 string 的操作，尽可能使用 <code class="highlighter-rouge">bytes.Buffer</code>，其底层使用 []byte 进行数据的存储，动态扩展，效率相对高。</p>

<h2 id="标准输入">标准输入</h2>

<p>类似于 C，Go 提供 <code class="highlighter-rouge">fmt.Scanf</code> 函数帮助我们从命令行中输入信息</p>

<h2 id="常量">常量</h2>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span><span class="x"> </span><span class="p">(</span><span class="x">
    </span><span class="n">a</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="m">1</span><span class="x">
    </span><span class="n">b</span><span class="x">
    </span><span class="n">c</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="m">2</span><span class="x">
    </span><span class="n">d</span><span class="x">
</span><span class="p">)</span><span class="x">
</span><span class="c">// a == b == 1</span><span class="x">
</span><span class="c">// c == d == 2</span><span class="x">
</span></code></pre></div></div>

<p>常量只能指向基本类型或者是经过 <code class="highlighter-rouge">type Time int</code> 等经过重命名的基本类型，但是许多常量并不从属某一具体类型。编译器将这些从属类型待定的常量表示为某些值，可以认为它们的精度至少达到 256 位。</p>

<h2 id="数组">数组</h2>

<p>声明数组时，使用 <code class="highlighter-rouge">...</code> 表示让编译器计算数组长度，不需要我们显式声明，如：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">r</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="m">1</span><span class="p">,</span><span class="x"> </span><span class="m">2</span><span class="p">,</span><span class="x"> </span><span class="m">3</span><span class="p">,</span><span class="x"> </span><span class="m">4</span><span class="p">}</span><span class="x">
</span><span class="n">s</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">1</span><span class="p">,</span><span class="x"> </span><span class="m">2</span><span class="p">,</span><span class="x"> </span><span class="m">3</span><span class="p">,</span><span class="x"> </span><span class="m">4</span><span class="p">}</span><span class="x">
</span><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%T</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="x"> </span><span class="n">r</span><span class="p">)</span><span class="x">   </span><span class="c">// [4]int 数组</span><span class="x">
</span><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%T</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="x"> </span><span class="n">s</span><span class="p">)</span><span class="x">   </span><span class="c">// []int slice</span><span class="x">
</span></code></pre></div></div>

<p>同类型的数组是可以通过 <code class="highlighter-rouge">==</code> 或 <code class="highlighter-rouge">!=</code> 进行比较的，这里需要注意的是 <code class="highlighter-rouge">[3]int [4]int</code> 不是同类型。</p>

<p>在函数的参数传递中，数组发生的是值传递，也就是每一次传递都在内存分配一样大小的空间，再进行数组内容的复制，在函数内改变数组元素不会影响到原数组。如果传递大数组将会十分低效。所以需要进行函数传递的建议使用 slice，slice 是一个结构体，不会发生底层数组的复制，只是将复制指针值；或者使用数组的指针进行数组的传递。</p>

<p>Go 内置函数很多都是直接对 slice 进行传递和操作，感觉 Go 还是建议人们尽可能使用 slice 而不是数组。</p>

<h2 id="slice">slice</h2>

<p>声明数组或 slice 的时候，可以指定特定位置元素的值，如果之前的值没有显示声明，就会被声明为默认值。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="m">99</span><span class="o">:</span><span class="m">1</span><span class="p">}</span><span class="x"> </span><span class="c">// 声明一个 [100]int 数组，0~98 为 int 默认值 0，99 位元素为 1</span><span class="x">
</span><span class="n">s</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">99</span><span class="o">:</span><span class="m">1</span><span class="p">}</span><span class="x"> </span><span class="c">// 声明一个 []int slice，0~98 为 int 默认值 0,99 位元素为 1</span><span class="x">
</span></code></pre></div></div>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">days</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="m">1</span><span class="o">:</span><span class="s">"Sunday"</span><span class="p">,</span><span class="x"> </span><span class="s">"Monday"</span><span class="p">,</span><span class="x"> </span><span class="s">"Tuesday"</span><span class="p">,</span><span class="x"> </span><span class="s">"Wednesday"</span><span class="p">,</span><span class="x"> </span><span class="s">"Thursday"</span><span class="p">,</span><span class="x"> </span><span class="s">"Friday"</span><span class="p">,</span><span class="x"> </span><span class="s">"Saturday"</span><span class="p">}</span><span class="x">
</span><span class="n">p</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">days</span><span class="p">[</span><span class="m">1</span><span class="o">:</span><span class="m">3</span><span class="p">]</span><span class="x">
</span><span class="n">t</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">p</span><span class="p">[</span><span class="m">0</span><span class="o">:</span><span class="m">5</span><span class="p">]</span><span class="x">
</span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="x"> </span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">),</span><span class="x"> </span><span class="nb">cap</span><span class="p">(</span><span class="n">p</span><span class="p">))</span><span class="x">
</span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="x"> </span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="x"> </span><span class="nb">cap</span><span class="p">(</span><span class="n">t</span><span class="p">))</span><span class="x">
</span></code></pre></div></div>

<p>注意：<code class="highlighter-rouge">len(p) == 2</code> 为什么可以取 <code class="highlighter-rouge">t := p[0:5]</code> 长度为 5 的 slice 呢？</p>

<p>因为 <code class="highlighter-rouge">cap(p) == 7</code>，p 底层数组复用了 days，也就是说只要不超越 <strong>cap</strong> 限制，就可以取任意长度的切片。</p>

<p>slice 取切片都使用指针复用了底层的数组，所以 slice 的取切片操作是一个高效的操作，并不会占用很多资源，问题是 slice 底层复用数组，有可能一个改变会影响其他的运行结果，尤其是在 goroutine 众多的情况下。</p>

<p>如果库支持的函数中只支持对应类型的 slice，而不支持数组类型参数怎么办呢？
比如：<code class="highlighter-rouge">func test([]byte)</code> 函数只支持 []byte，而不支持 [N]byte</p>

<p>可以通过对数组取切片，得到的 slice 复用了底层的数组存储空间。
如：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="p">[</span><span class="m">3</span><span class="p">]</span><span class="kt">byte</span><span class="p">{</span><span class="m">1</span><span class="p">,</span><span class="x"> </span><span class="m">2</span><span class="p">,</span><span class="x"> </span><span class="m">3</span><span class="p">}</span><span class="x">
</span><span class="n">test</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="o">:</span><span class="p">])</span><span class="x">
</span></code></pre></div></div>

<p>一个等于 nil 的 slice 与<code class="highlighter-rouge">len==cap==0</code> 的 slice 有的唯一区别就是，与 nil 进行 <code class="highlighter-rouge">==</code> <code class="highlighter-rouge">!=</code> 比较时的表现相反。</p>

<p><strong>下面将会变得非常绕</strong></p>

<p><a href="https://stackoverflow.com/questions/18512781/built-in-source-code-location">stackoverflow 上一个关于 copy make 等内置函数的讨论</a></p>

<p>一个例子：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">1</span><span class="p">,</span><span class="x"> </span><span class="m">2</span><span class="p">,</span><span class="x"> </span><span class="m">3</span><span class="p">,</span><span class="x"> </span><span class="m">4</span><span class="p">}</span><span class="x">
</span><span class="nb">copy</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="m">1</span><span class="o">:</span><span class="p">],</span><span class="x"> </span><span class="n">s</span><span class="p">[</span><span class="m">0</span><span class="o">:</span><span class="m">2</span><span class="p">])</span><span class="x">
</span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="x">  </span><span class="c">// [1 1 2 4]</span><span class="x">
</span></code></pre></div></div>

<p>这里得出的结论是 copy 函数应该是从后往前复制的，如果是从前往后复制的话得到的结果是 <code class="highlighter-rouge">[1 1 1 4]</code></p>

<p>另一个例子：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">1</span><span class="p">,</span><span class="x"> </span><span class="m">2</span><span class="p">,</span><span class="x"> </span><span class="m">3</span><span class="p">,</span><span class="x"> </span><span class="m">4</span><span class="p">}</span><span class="x">
</span><span class="nb">copy</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="m">0</span><span class="o">:</span><span class="p">],</span><span class="x"> </span><span class="n">s</span><span class="p">[</span><span class="m">1</span><span class="o">:</span><span class="p">])</span><span class="x">
</span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="x">  </span><span class="c">// [2 3 4 4]</span><span class="x">
</span></code></pre></div></div>

<p>这里得出的结论是 copy 函数应该是从前往后复制的，如果是从后往前复制的话得到的结果是 <code class="highlighter-rouge">[4 4 4 4]</code></p>

<p>这让我产生疑问，<code class="highlighter-rouge">copy</code> 函数的复制算法到第是怎么样的呢？</p>

<p><strong>copy</strong> 函数的实现</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">slicecopy</span><span class="p">(</span><span class="n">to</span><span class="p">,</span><span class="x"> </span><span class="n">fm</span><span class="x"> </span><span class="n">slice</span><span class="p">,</span><span class="x"> </span><span class="n">width</span><span class="x"> </span><span class="kt">uintptr</span><span class="p">)</span><span class="x"> </span><span class="kt">int</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="k">if</span><span class="x"> </span><span class="n">fm</span><span class="o">.</span><span class="nb">len</span><span class="x"> </span><span class="o">==</span><span class="x"> </span><span class="m">0</span><span class="x"> </span><span class="o">||</span><span class="x"> </span><span class="n">to</span><span class="o">.</span><span class="nb">len</span><span class="x"> </span><span class="o">==</span><span class="x"> </span><span class="m">0</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="k">return</span><span class="x"> </span><span class="m">0</span><span class="x">
    </span><span class="p">}</span><span class="x">

    </span><span class="n">n</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">fm</span><span class="o">.</span><span class="nb">len</span><span class="x">
    </span><span class="k">if</span><span class="x"> </span><span class="n">to</span><span class="o">.</span><span class="nb">len</span><span class="x"> </span><span class="o">&lt;</span><span class="x"> </span><span class="n">n</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="n">n</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">to</span><span class="o">.</span><span class="nb">len</span><span class="x">
    </span><span class="p">}</span><span class="x">

    </span><span class="k">if</span><span class="x"> </span><span class="n">width</span><span class="x"> </span><span class="o">==</span><span class="x"> </span><span class="m">0</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="k">return</span><span class="x"> </span><span class="n">n</span><span class="x">
    </span><span class="p">}</span><span class="x">
    </span><span class="c">// 忽略中间某些关于 race 的细节</span><span class="x">
    </span><span class="n">size</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="kt">uintptr</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="x"> </span><span class="o">*</span><span class="x"> </span><span class="n">width</span><span class="x">
    </span><span class="k">if</span><span class="x"> </span><span class="n">size</span><span class="x"> </span><span class="o">==</span><span class="x"> </span><span class="m">1</span><span class="x"> </span><span class="p">{</span><span class="x"> </span><span class="c">// common case worth about 2x to do here</span><span class="x">
        </span><span class="c">// TODO: is this still worth it with new memmove impl?</span><span class="x">
        </span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">byte</span><span class="p">)(</span><span class="n">to</span><span class="o">.</span><span class="n">array</span><span class="p">)</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">byte</span><span class="p">)(</span><span class="n">fm</span><span class="o">.</span><span class="n">array</span><span class="p">)</span><span class="x"> </span><span class="c">// known to be a byte pointer</span><span class="x">
    </span><span class="p">}</span><span class="x"> </span><span class="k">else</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="n">memmove</span><span class="p">(</span><span class="n">to</span><span class="o">.</span><span class="n">array</span><span class="p">,</span><span class="x"> </span><span class="n">fm</span><span class="o">.</span><span class="n">array</span><span class="p">,</span><span class="x"> </span><span class="n">size</span><span class="p">)</span><span class="x">
    </span><span class="p">}</span><span class="x">
    </span><span class="k">return</span><span class="x"> </span><span class="n">n</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p><code class="highlighter-rouge">memmove</code> 的实现在 <a href="https://github.com/golang/go/blob/master/src/runtime/memmove_amd64.s">https://github.com/golang/go/blob/master/src/runtime/memmove_amd64.s</a> 由于全是汇编没有看懂。</p>

<p>如果需要实现 slice 的循环移动的话，我们可以通过三次翻手实现：</p>

<p>比如需要把 <code class="highlighter-rouge">[1 2 3 4 5]</code> 循环移动为 <code class="highlighter-rouge">[3 4 5 1 2]</code></p>

<ol>
  <li>把 <code class="highlighter-rouge">[1 2]</code> 旋转为 <code class="highlighter-rouge">[2 1]</code></li>
  <li>把 <code class="highlighter-rouge">[3 4 5]</code> 旋转为 <code class="highlighter-rouge">[5 4 3]</code></li>
  <li>此时 slice 已经变成 <code class="highlighter-rouge">[2 1 5 4 3]</code>，再进行一次翻手得到 <code class="highlighter-rouge">[3 4 5 1 2]</code></li>
</ol>

<h2 id="map">map</h2>

<p>键 K 必须能够通过操作符 <code class="highlighter-rouge">==</code> 进行比较，选 K 的时候尽可能不适用浮点型，虽然浮点型可以通过 <code class="highlighter-rouge">==</code> 进行比较，但是比较存在不精确，通常我们比较字符串是通过一个阀值做到的，比如 <code class="highlighter-rouge">1 - 0.001 &lt;= f &lt;= 1 + 0.001</code>。</p>

<p><code class="highlighter-rouge">delete</code> 函数从 map 中删除指定的 K-V，即使 K 不存在于 map 中也不会发生异常，如果从 map 中取出一个 K，如果该 K 不存在 map 中会返回一个类型 K 的零值，所以通常取元素操作会附带一个 comma-ok如：<code class="highlighter-rouge">v, ok := m[k]</code>。</p>

<p>map 元素不是一个变量，无法获取它们的地址，如下操作是不能够通过编译的：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%p"</span><span class="p">,</span><span class="x"> </span><span class="o">&amp;</span><span class="n">m</span><span class="p">[</span><span class="s">"hello"</span><span class="p">])</span><span class="x">
</span></code></pre></div></div>

<p>原因是 map 是有可能动态增长的，当发生动态增长的时候，K-V 所在的地址发生了迁移，通过获取 <code class="highlighter-rouge">&amp;m["hello"]</code> 没有意义，地址无效。</p>

<p>可以通过 <code class="highlighter-rouge">len</code> 函数获知 map 中 K-V 的数量。</p>

<p>map 的零值是 nil，向 nil map 中查找元素、<code class="highlighter-rouge">len(m)</code>、<code class="highlighter-rouge">delete(m, k)</code>、for range 循环，都不会发生错误，其行为像对已经初始化但是依然是空的 map 操作一样，但是如果向 nil map 中设置 K-V 将会导致错误。</p>

<h2 id="struct">struct</h2>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span><span class="x"> </span><span class="n">p</span><span class="x">
</span><span class="k">type</span><span class="x"> </span><span class="n">T</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="n">a</span><span class="p">,</span><span class="x"> </span><span class="n">b</span><span class="x"> </span><span class="kt">int</span><span class="p">}</span><span class="x">

</span><span class="k">package</span><span class="x"> </span><span class="n">q</span><span class="x">
</span><span class="k">import</span><span class="x"> </span><span class="s">"p"</span><span class="x">
</span><span class="k">var</span><span class="x"> </span><span class="n">a</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">p</span><span class="o">.</span><span class="n">T</span><span class="p">{</span><span class="n">a</span><span class="o">:</span><span class="m">1</span><span class="p">,</span><span class="x"> </span><span class="n">b</span><span class="o">:</span><span class="x"> </span><span class="m">2</span><span class="p">}</span><span class="x">  </span><span class="c">// 编译错误</span><span class="x">
</span><span class="k">var</span><span class="x"> </span><span class="n">b</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">p</span><span class="o">.</span><span class="n">T</span><span class="p">{</span><span class="m">1</span><span class="p">,</span><span class="x"> </span><span class="m">2</span><span class="p">}</span><span class="x">       </span><span class="c">// 编译错误</span><span class="x">
</span></code></pre></div></div>

<p>因为 a b 是以小写开头的，都是不可导出的，在别的包下无法显示 <code class="highlighter-rouge">p.T{a:1, b: 2}</code> 或隐式 <code class="highlighter-rouge">p.T{1, 2}</code> 引用。</p>

<p>如果一个结构体中所有的成员都是可以比较的，那么这个结构体就是可以比较的；否则该结构体不能够通过 <code class="highlighter-rouge">==</code> <code class="highlighter-rouge">!=</code> 进行比较，可以比较的结构体可以作为 map 的 K。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// 可比较的结构体</span><span class="x">
</span><span class="k">type</span><span class="x"> </span><span class="n">Point</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">X</span><span class="p">,</span><span class="x"> </span><span class="n">Y</span><span class="x"> </span><span class="kt">int</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="c">// 不可比较的结构体</span><span class="x">
</span><span class="k">type</span><span class="x"> </span><span class="n">array</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">S</span><span class="x"> </span><span class="p">[]</span><span class="kt">int</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>结构体可以组合是 Go 实现面相对象的重要部分。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span><span class="x"> </span><span class="n">Point</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">X</span><span class="p">,</span><span class="x"> </span><span class="n">Y</span><span class="x"> </span><span class="kt">int</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">type</span><span class="x"> </span><span class="n">Circle</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">Point</span><span class="x">
    </span><span class="n">Radius</span><span class="x"> </span><span class="kt">int</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>这样 Circle 就能够调用 Point 的方法，Circle 中 Point 的名字就是 Point，也就是 Cicle 中不能够再有名为 Point 的成员了。</p>

<h1 id="函数">函数</h1>

<p>许多编程语言都为线程分配一个固定长度的函数调用栈，大小在 64KB 到 2MB 之间，递归的深度受限于固定长度大小栈，Go 语言实现了可变长的栈，栈的使用会随着使用的增大而增大，可达到 1GB 左右的上限，这样我们可以安全地使用递归而不用担心栈溢出。当然在栈编程的时候像是 slice、map 的扩展，会出现内存的复制，频繁增长会使效率降低。</p>

<p>Go 垃圾回收机制可回收未使用的内存，但不能指望它会释放未使用的操作系统资源，比如打开文件以及网络连接等，<strong>必须显示关闭操作系统资源</strong>。</p>

<p>可变参数传递的是一个对应类型的 slice，如：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">sum</span><span class="p">(</span><span class="n">vals</span><span class="x"> </span><span class="o">...</span><span class="kt">int</span><span class="p">)</span><span class="x">
</span></code></pre></div></div>

<p>vals 是一个 <code class="highlighter-rouge">[]int</code> 的 slice</p>

<h2 id="defer">defer</h2>

<p>使用 defer 语句正确的地方是在成功获得资源后。</p>

<p>值得一提是先生成 <strong>return</strong> 返回的值，然后再以先入后出的顺序执行 <strong>defer</strong> 语句。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">a</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">test</span><span class="p">()</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">test</span><span class="p">()</span><span class="x"> </span><span class="kt">int</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">a</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">0</span><span class="x">
    </span><span class="k">defer</span><span class="x"> </span><span class="k">func</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="x">
    </span><span class="p">}()</span><span class="x">
    </span><span class="k">defer</span><span class="x"> </span><span class="k">func</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="n">a</span><span class="o">++</span><span class="x">
    </span><span class="p">}()</span><span class="x">
    </span><span class="k">return</span><span class="x"> </span><span class="n">a</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>输出：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1
0
</code></pre></div></div>

<p>但是如果返回值有命名，那么 defer 修改命名返回值可以修改外围调用者接收到的返回值，如：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">a</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">test2</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">test2</span><span class="p">(</span><span class="n">x</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="p">(</span><span class="n">result</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="k">defer</span><span class="x"> </span><span class="k">func</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="n">result</span><span class="x"> </span><span class="o">+=</span><span class="x"> </span><span class="n">x</span><span class="p">}()</span><span class="x">
    </span><span class="k">return</span><span class="x"> </span><span class="n">x</span><span class="x"> </span><span class="o">+</span><span class="x"> </span><span class="n">x</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>输出： <code class="highlighter-rouge">3</code></p>

<h2 id="闭包">闭包</h2>

<p>Go 中闭包的实现是通过 <strong>逃逸分析</strong> 做到的，通过分析变量是否有逃逸的可能，如果有则把变量创建在堆中，否则变量分配在当前 goroutine 的栈中。</p>

<p>变量在同一个包下都是可见的，无论该属性是否是可导出的<em>exported</em></p>

<p>Go 语法糖（由编译器实现的便利功能）之一是：对于方法的接收者是<strong>值</strong>或者<strong>指针</strong>，Go 编译器会帮助我们实现<strong>取值<code class="highlighter-rouge">*</code></strong>和<strong>取地址<code class="highlighter-rouge">&amp;</code></strong>操作。如：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span><span class="x"> </span><span class="n">S</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">s</span><span class="x"> </span><span class="kt">string</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">s</span><span class="x"> </span><span class="o">*</span><span class="n">S</span><span class="p">)</span><span class="x"> </span><span class="n">hello</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"hello,"</span><span class="p">,</span><span class="x"> </span><span class="n">s</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">s</span><span class="x"> </span><span class="n">S</span><span class="p">)</span><span class="x"> </span><span class="n">world</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"world wide web"</span><span class="p">,</span><span class="x"> </span><span class="n">s</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">s</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">S</span><span class="p">{</span><span class="n">s</span><span class="o">:</span><span class="x"> </span><span class="s">"world"</span><span class="p">}</span><span class="x">
    </span><span class="n">s</span><span class="o">.</span><span class="n">hello</span><span class="p">()</span><span class="x">  </span><span class="c">// OK</span><span class="x">
    </span><span class="n">p</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="o">&amp;</span><span class="n">s</span><span class="x">
    </span><span class="n">p</span><span class="o">.</span><span class="n">world</span><span class="p">()</span><span class="x">  </span><span class="c">// OK</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>但是自动 <code class="highlighter-rouge">*</code> 和 <code class="highlighter-rouge">&amp;</code> 操作只能针对变量有效，对于类型的字面量不起作用，如：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">S</span><span class="p">{</span><span class="n">s</span><span class="o">:</span><span class="x"> </span><span class="s">"world"</span><span class="p">}</span><span class="o">.</span><span class="n">hello</span><span class="p">()</span><span class="x">   </span><span class="c">// 编译错误</span><span class="x">
</span></code></pre></div></div>

<h2 id="nil-是合法的方法接收者">nil 是合法的方法接收者</h2>

<p>因为很多类型中 nil 是有意义的，比如 slice、map、chan，只要将 nil 转化为其他可以为 nil 的类型，那么 nil 也可以作为方法的接收者。比如一个链表的例子：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span><span class="x"> </span><span class="n">IntList</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">Val</span><span class="x"> </span><span class="kt">int</span><span class="x">
    </span><span class="n">Next</span><span class="x"> </span><span class="o">*</span><span class="n">IntList</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">node</span><span class="x"> </span><span class="o">*</span><span class="n">IntList</span><span class="p">)</span><span class="x"> </span><span class="n">Sum</span><span class="p">()</span><span class="x"> </span><span class="kt">int</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="k">if</span><span class="x"> </span><span class="n">node</span><span class="x"> </span><span class="o">==</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="k">return</span><span class="x"> </span><span class="m">0</span><span class="x">
    </span><span class="p">}</span><span class="x">
    </span><span class="k">return</span><span class="x"> </span><span class="n">node</span><span class="o">.</span><span class="n">Val</span><span class="x"> </span><span class="o">+</span><span class="x"> </span><span class="n">node</span><span class="o">.</span><span class="n">Next</span><span class="o">.</span><span class="n">Sum</span><span class="p">()</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>如果不是环形链表的话，那么最后一个结点的 <code class="highlighter-rouge">node.Next == nil</code>，使用 <code class="highlighter-rouge">node.Next.Sum()</code> 可以正常运行。对于方法的接收者可以是 nil 的情况下要多加小心，比如修改 nil map 可能会触发宕机 panic。</p>

<h2 id="方法函数变量">方法函数变量</h2>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span><span class="x"> </span><span class="n">S</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">s</span><span class="x"> </span><span class="kt">string</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">s</span><span class="x"> </span><span class="o">*</span><span class="n">S</span><span class="p">)</span><span class="x"> </span><span class="n">hello</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"hello,"</span><span class="p">,</span><span class="x"> </span><span class="n">s</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">s</span><span class="x"> </span><span class="n">S</span><span class="p">)</span><span class="x"> </span><span class="n">world</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"world wide web"</span><span class="p">,</span><span class="x"> </span><span class="n">s</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">test1</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">s</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">S</span><span class="p">{</span><span class="n">s</span><span class="o">:</span><span class="x"> </span><span class="s">"world"</span><span class="p">}</span><span class="x">
    </span><span class="n">f</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">s</span><span class="o">.</span><span class="n">hello</span><span class="x">
    </span><span class="n">s</span><span class="o">.</span><span class="n">s</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="s">"hi"</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%T</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="x"> </span><span class="n">f</span><span class="p">)</span><span class="x">
    </span><span class="n">f</span><span class="p">()</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">test2</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">p</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="o">&amp;</span><span class="n">S</span><span class="p">{</span><span class="n">s</span><span class="o">:</span><span class="x"> </span><span class="s">"world"</span><span class="p">}</span><span class="x">
    </span><span class="n">f</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">p</span><span class="o">.</span><span class="n">world</span><span class="x">
    </span><span class="n">p</span><span class="o">.</span><span class="n">s</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="s">"ja"</span><span class="x">
    </span><span class="n">f</span><span class="p">()</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>test1 函数输出：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func()
hello, &amp;{hi}
</code></pre></div></div>

<p>也就是修改了 <code class="highlighter-rouge">s.s</code> 的值后，<code class="highlighter-rouge">f()</code> 方法的调用收到了影响。</p>

<p>test2 函数输出：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>world wide web {world}
</code></pre></div></div>

<p>也就是修改了 <code class="highlighter-rouge">p.s</code> 的值后，<code class="highlighter-rouge">f()</code> 方法的调用不受影响。</p>

<p>分析：因为 test1 中 f 方法保存的是 (s *S) 指针，他们始终引用同一个地址，所以修改了引用的地址的值，<code class="highlighter-rouge">f()</code> 也会受到影响。test2 中 f 方法保存的是 (s S) 值，与 p 指针指向的地址不一样，因为 s 已经经过了值复制，修改 p 并不会影响到 s，所以 <code class="highlighter-rouge">f()</code> 调用不受影响。</p>

<blockquote>
  <p>如果使用方法函数变量，请注意如果类型中对应有引用，可能会发生难以排查的错误</p>
</blockquote>

<h2 id="集和的实现">集和的实现</h2>

<p>Go 并没有 build-in 集和 set（Python 有，Java 也有），而 map 与 set 非常相似，只是 map 存储的是 K-V，set 存储的是 K，可以通过把 V 插入一个 bool 值来达到把 map 改装为 set 的功能。</p>

<p>PS：Java 中的 HashSet 就是把 HashMap 中的 V 架空实现的，其他算法和 HashpMap 几乎一样。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span><span class="x"> </span><span class="n">set</span><span class="x"> </span><span class="k">map</span><span class="p">[</span><span class="n">T</span><span class="p">]</span><span class="kt">bool</span><span class="x">
</span></code></pre></div></div>

  </div>

  

  <a class="u-url" href="/golang/2018/03/02/the-go-programing-languange-note1.html" hidden></a>
</article>

      </div>
    </main>

    <footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">刘曦光</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">
            
              刘曦光
            
            </li>
            
            <li><a class="u-email" href="mailto:g10guang@foxmail.com">g10guang@foxmail.com</a></li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
  
  
  
  <li><a href="https://github.com/g10guang"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">g10guang</span></a></li>
  
  
  
  
  
  
  
</ul>

      </div>

      <div class="footer-col footer-col-3">
        <p>我会在这里分享我的成长经历、心得，既有IT方面的，也有生活读书方面的。</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
