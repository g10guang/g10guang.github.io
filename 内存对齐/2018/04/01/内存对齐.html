<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Begin Jekyll SEO tag v2.4.0 -->
<title>内存对齐 | 刘曦光</title>
<meta name="generator" content="Jekyll v3.7.2" />
<meta property="og:title" content="内存对齐" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="本机器 64 位操作系统" />
<meta property="og:description" content="本机器 64 位操作系统" />
<link rel="canonical" href="http://localhost:4000/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/2018/04/01/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90.html" />
<meta property="og:url" content="http://localhost:4000/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/2018/04/01/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90.html" />
<meta property="og:site_name" content="刘曦光" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-04-01T09:00:05+08:00" />
<script type="application/ld+json">
{"description":"本机器 64 位操作系统","@type":"BlogPosting","url":"http://localhost:4000/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/2018/04/01/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90.html","headline":"内存对齐","dateModified":"2018-04-01T09:00:05+08:00","datePublished":"2018-04-01T09:00:05+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/2018/04/01/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <link rel="stylesheet" href="/assets/main.css">
  <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="刘曦光" />
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">
    
    
    <a class="site-title" rel="author" href="/">刘曦光</a>

    
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
          
            
            
            <a class="page-link" href="/about/">About</a>
            
          
            
            
          
            
            
          
            
            
          
        </div>
      </nav>
    
  </div>
</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">内存对齐</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2018-04-01T09:00:05+08:00" itemprop="datePublished">
        
        Apr 1, 2018
      </time>
      </p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <blockquote>
  <p>本机器 64 位操作系统</p>
</blockquote>

<h1 id="为什么有内存对齐">为什么有内存对齐？</h1>

<p>这是对时间和空间的双重优化，比如 64 位系统数据总线大小为 64 位，使用内存对齐方案就可以一次从内存中加载更多数据，比如 64 位中可以存放 <code class="highlighter-rouge">char[4] + int</code>。CPU 中的高速缓存是非常小的，本 CPU 是 4 核 8 线程，每一个线程的高速缓存是 6144KB。</p>

<p>既然有这么好的方案，Why not?</p>

<p>C/Cpp 中的内存对齐方案同样适用于 Golang 和 Rust。</p>

<h1 id="c-中基本类型大小">C 中基本类型大小</h1>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"int=%ld char=%ld float=%ld double=%ld long=%ld pointer=%ld long double=%ld</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span> <span class="kt">double</span><span class="p">));</span>
</code></pre></div></div>

<p>output:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int=4 char=1 float=4 double=8 long=8 pointer=8 long double=16
</code></pre></div></div>

<ul>
  <li>数组类型大小 = 类型大小 * 数组大小     # 数组长度为 0 很奇怪</li>
  <li>指针大小 = 操作系统字长               # 本机器中为 <code class="highlighter-rouge">64 / 8 = 8</code></li>
</ul>

<h1 id="对齐方式">对齐方式</h1>

<p><strong>C 的变量不是能够存放在任意地址的</strong>，限制：变量存放的起始位置必须是类型大小的整数倍。</p>

<ul>
  <li>char：<code class="highlighter-rouge">sizeof(char) == 1</code> char 能够存放在任何起始地址</li>
  <li>short：<code class="highlighter-rouge">sizeof(short) == 2</code> short 的起始地址必须是 2 的整数倍</li>
  <li>int：<code class="highlighter-rouge">sizeof(int) == 4</code> int 的起始地址必须是 4 的整数倍</li>
  <li>float：与 int 一样</li>
  <li>double：<code class="highlighter-rouge">sizeof(double) == 8</code> double 的起始地址必须是 8 的整数倍</li>
  <li>long：与 doubel 一样</li>
</ul>

<blockquote>
  <p>起始地址至于类型大小有关，与有无符号类型无关</p>
</blockquote>

<p>填充 padding 的值不确定，这不影响程序员编程，因为我们根本不会访问到 padding。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// A</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">c</span><span class="p">;</span>

<span class="c1">// B</span>
<span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</code></pre></div></div>

<p>使用 A 方案可能会比 B 方案浪费更多内存。因为 A 方案的指针需要进行内存对齐，p 的起始存储地址必须是 8 的整数倍，而 B 方案的字符类型 c 可以存放在任何起始地址。</p>

<h2 id="struct-结构体">struct 结构体</h2>

<p>结构体的大小会根据其内部最长<strong>基本类型</strong>对齐，这句话听起来确实比较别扭，举些例子：</p>

<blockquote>
  <p>基本类型最长为 16 字节，long double</p>
</blockquote>

<p>有以下结构体：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">foo</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>其对应的内存布局为：</p>

<table>
  <thead>
    <tr>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
      <th>5</th>
      <th>6</th>
      <th>7</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>p</td>
      <td>p</td>
      <td>p</td>
      <td>p</td>
      <td>p</td>
      <td>p</td>
      <td>p</td>
      <td>p</td>
    </tr>
    <tr>
      <td>x</td>
      <td>x</td>
      <td>x</td>
      <td>x</td>
      <td>x</td>
      <td>x</td>
      <td>x</td>
      <td>x</td>
    </tr>
    <tr>
      <td>c</td>
      <td>pad</td>
      <td>pad</td>
      <td>pad</td>
      <td>pad</td>
      <td>pad</td>
      <td>pad</td>
      <td>pad</td>
    </tr>
  </tbody>
</table>

<p>第三行的 1~7 字节仍然属于结构体 foo。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">A</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span><span class="n">A</span><span class="p">;</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">sizeof(A) == 4</code>，因为其类型内部最长基本类型是 int，长度为 4 字节。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">B</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">A</span> <span class="n">a</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">sizeof(B) == 8</code> 其内部最长基本类型为 int，<code class="highlighter-rouge">type(A.a) == int</code>，所以长度需要是 4 的倍数，最后 B 中的填充应该为：</p>

<table>
  <thead>
    <tr>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
      <th>5</th>
      <th>6</th>
      <th>7</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>b</td>
      <td>pad</td>
      <td>pad</td>
      <td>pad</td>
      <td>A.a</td>
      <td>A.a</td>
      <td>A.a</td>
      <td>A.a</td>
    </tr>
  </tbody>
</table>

<h2 id="pragma-packn">#pragma pack(n)</h2>

<p>在代码中使用 <code class="highlighter-rouge">#pragma pack(n)</code> 可以指定对齐系数，n=1,2,4,8,16（在不同平台下的不同编译器支持不一样），希望通过举几个例子让大家更好的理解其工作方式：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Test</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">a</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>在 64 位系统中的对齐应该如下：</p>

<table>
  <thead>
    <tr>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
      <th>5</th>
      <th>6</th>
      <th>7</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>a(0)</td>
      <td>pad</td>
      <td>pad</td>
      <td>pad</td>
      <td>b(0)</td>
      <td>b(1)</td>
      <td>b(2)</td>
      <td>b(3)</td>
    </tr>
    <tr>
      <td>c(0)</td>
      <td>pad</td>
      <td>pad</td>
      <td>pad</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>显而易见，<code class="highlighter-rouge">sizeof(Test) == 12</code>，其中第二行的 4~7 字节已经不属于 Test 结构体的部分。</p>

<p>如果使用 <code class="highlighter-rouge">#pragma pack(1)</code></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma pack(1)
</span><span class="k">struct</span> <span class="n">Test</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">a</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">sizeof(Test) == 6</code>，为什么？请看下面的内存对齐方式：</p>

<table>
  <thead>
    <tr>
      <th>0</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>c(0)</td>
    </tr>
    <tr>
      <td>b(0)</td>
    </tr>
    <tr>
      <td>b(1)</td>
    </tr>
    <tr>
      <td>b(2)</td>
    </tr>
    <tr>
      <td>b(3)</td>
    </tr>
    <tr>
      <td>c(0)</td>
    </tr>
  </tbody>
</table>

<p>如果使用 <code class="highlighter-rouge">#pragma pack(2)</code></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma pack(2)
</span><span class="k">struct</span> <span class="n">Test</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">a</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">sizeof(Test) == 8</code>，为什么？请看下面内存对齐方式：</p>

<table>
  <thead>
    <tr>
      <th>0</th>
      <th>1</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>a(0)</td>
      <td>pad</td>
    </tr>
    <tr>
      <td>b(0)</td>
      <td>b(1)</td>
    </tr>
    <tr>
      <td>b(2)</td>
      <td>b(3)</td>
    </tr>
    <tr>
      <td>c(0)</td>
      <td>pad</td>
    </tr>
  </tbody>
</table>

<p>如果使用 <code class="highlighter-rouge">#pragma pack(4)</code></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma pack(4)
</span><span class="k">struct</span> <span class="n">Test</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">a</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">b</span><span class="p">;</span>   <span class="c1">// 注意这里改为了 double 类型</span>
    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">sizeof(Test) == 12</code>，为什么？请看下面内存对齐方式：</p>

<table>
  <thead>
    <tr>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>a(0)</td>
      <td>pad</td>
      <td>pad</td>
      <td>pad</td>
    </tr>
    <tr>
      <td>b(0)</td>
      <td>b(1)</td>
      <td>b(2)</td>
      <td>b(3)</td>
    </tr>
    <tr>
      <td>b(4)</td>
      <td>b(5)</td>
      <td>b(6)</td>
      <td>b(7)</td>
    </tr>
    <tr>
      <td>c(0)</td>
      <td>pad</td>
      <td>pad</td>
      <td>pad</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>#pragma pack(n)，如果 n * 8 &gt;= 当前操作系统位数，则与不使用 #pragma pack 是一样的效果。</p>
</blockquote>

<h2 id="长度为-0-的数组">长度为 0 的数组</h2>

<p>前面提到长度为 0 的数组表现得很奇怪。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%ld</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="p">));</span> <span class="c1">// 0</span>
<span class="p">}</span>
</code></pre></div></div>

<p>长度为 0 的数组有什么用呢？</p>

<p><strong>可以实现动态分配数组长度</strong>。不知道读者写 C 的时候有没有一种很不爽的感觉，就是声明数组的时候一定需要声明常数长度数组，一点都不灵活。有兴趣的读者可以参考：<a href="https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html">Using the GNU Compiler Collection (GCC): Zero Length</a></p>

<h1 id="谁去完成内存对齐的工作">谁去完成内存对齐的工作？</h1>

<p><strong>编译器</strong></p>

<p>编译器能够为代码做很多优化，比如使生成的目标程序最小等，但是 C 编译器<strong>不会自动</strong>进行结构体的变量顺序的优化，因为 C 是一门主要面相操作系统等控制硬件的软件开发，如果 C 擅自进行了结构体中变量顺序的优化有可能导致异常行为。因为很多硬件信号都是通过某一特定位来控制的。</p>

  </div>

  

  <a class="u-url" href="/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/2018/04/01/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90.html" hidden></a>
</article>

      </div>
    </main>

    <footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">刘曦光</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">
            
              刘曦光
            
            </li>
            
            <li><a class="u-email" href="mailto:g10guang@foxmail.com">g10guang@foxmail.com</a></li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
  
  
  
  <li><a href="https://github.com/g10guang"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">g10guang</span></a></li>
  
  
  
  
  
  
  
</ul>

      </div>

      <div class="footer-col footer-col-3">
        <p>我会在这里分享我的成长经历、心得，既有IT方面的，也有生活读书方面的。</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
